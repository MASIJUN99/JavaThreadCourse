# 十六、Java内存模型

JMM即Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等

JMM体现在以下几个方面:
1. 原子性: 保证指令不会受到线程上下文切换影响
2. 可见性: 保证指令不会受CPU缓存影响
3. 有序性: 保证指令不会受CPU指令并行优化的影响

## （一）可见性

### 退不出的循环

```java
public class Test {
    private static boolean run = true;

    public static void main(String[] args) {
        Thread t = new Thread(() -> {
            while (run) {
                // ...
            }
        });
        t.start();
        
        Thread.sleep(1000);
        run = false;
    }
}
```

这样运行，发现并不会退出循环。

### 为什么呢？
1. 初始状态，t线程刚开始从**主内存**中读取了run到**工作内存**中。
2. 因为t要频繁读取主内存的run，所以JIT编译器会将run的值缓存到自己的工作内存中的高速内存中，以减少对主存的读取，从而提升效率。
3. 1秒之后，main线程修改了run的值，并同步至主内存，但t是从自己的高速缓存中读取run，所以结果依旧是以前的值。

### 解决方法

给run变量添加`volatile`修饰符。

这个修饰符的意思是，线程不能在缓存中获取这个值。

虽然损失了效率，但是保证了共享变量的可见性！

这个修饰符叫: 易变关键字

## （二）原子性

一个变量加了volatile后不一定能保证这个变量是原子性的。

这个概念比较好理解，不多解释。

> 注意:
> 
> synchronized语句块既可以保证代码的原子性，也可以保证代码内变量的可见性，但是synchronized属于块级操作，效率会低。
> 
> 如果在前面的死循环中加入sout会发现不被volatile修饰的变量也能正确读取到，这是为什么。

### 两阶段终止volatile改进

原来的版本[TwoPhaseTermination](../../17-TestInterrupt/src/TestTwoPhaseTermination.java)

用volatile改进后

[参考代码](../../29-TwoPhaseTermination)

### 犹豫模式

Balking，在一个线程发现另一个线程在做同样的事情，那么就不需要做了，称为犹豫模式。

即，一个方法只能运行一次，定义一个变量来存储当前线程的运行状态，如果当前线程正在运行就不能再次运行直至占用的线程结束。

## （三）有序性

JVM会在不影响正确性的前提下，调整语句的执行书怒，思考下面一段代码。

```java
static int i;
static int j;

// 在某个线程执行赋值...
i = ...;
j = ...;
```

### 为什么要执行指令优化呢？

例如鱼罐头加工，分为五个步骤

1. 去鳞清洗 - 10分钟
2. 蒸煮沥水 - 10分钟
3. 加注汤料 - 10分钟
4. 杀菌出锅 - 10分钟
5. 真空封罐 - 10分钟

根据以上步骤，其实可以每个步骤不互相干扰的情况下，每个步骤一起执行。这个时候就需要编排。

总的指令运行时间没变化，但是增加了效率（吞吐量）。


