# 九、synchronized

## （一）上下文切换分析

从一个例子引出，让一个共享的`counter = 0`然后两个线程各自增自减5000次，结果会是0吗？

[参考代码](../../18-AdvanceSync/src/Sample.java)

答案肯定是不是的，这就是并发问题。

从字节码出发，i++和i--会有这样的代码

> 查看字节码的方法
> 
> 命令行敲入`javac <ClassName>.java`
> 
> 此时文件会被编译成.class文件，这个时候直接打开是不行的，再进行命令行操作`javap -c <ClassName>.class`

对于i++
```
getstatic    i
iconst_1
iadd
putstatic    i
```

对于i--
```
getstatic    i
iconst_1
isub
putstatic    i
```

多线程、分时系统会产生指令交错，导致得到的static i不一定是最终状态

### 临界区 Critical Section

* 一个程序运行多个线程本身是没有问题的
* 问题出在多个线程访问共享资源
    * 多个线程访问共享资源其实也没问题
    * 问题在多个线程之间指令交错！
    
* 一段代码块如果存在对共享资源的多线程读写操作，这个代码块称为临界区

### 竞态条件 Race Condition

多个线程在临界区内执行，由于代码块的执行序列不同而导致结果无法预测，称之为发生了竞态条件。

## （二）synchronized解决方案

两类解决方案：
1. 阻塞式：如synchronized、lock
2. 非阻塞式：原子变量

阻塞式就是俗称的，对象锁，采用互斥的方式，让同一时刻只有一个线程获得对象锁。

> **注意**
> 
> 虽然同步和互斥都可以用synchronized来完成，但是两者还是有区别的
> * 互斥是保证临界区内的竞态条件的发生，同一时刻只能有一个线程执行临界区代码
> * 同步锁是由于线程执行的先后、顺序不同，需要一个线程等其他线程运行到某个点

