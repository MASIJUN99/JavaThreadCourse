# 十、synchronized优化

## （一）轻量级锁

轻量级锁的使用场景：若有有一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁优化。

轻量级锁对使用者是透明的，即语法仍然是synchronized。（如果轻量级锁失败会调用重量级）

假设有两个同步方法块，利用同一个对象加锁。

```java
static final Object obj = new Object();
public static void method1() {
    synchronized(obj) {
        // 同步块
        method2();  // 重入
    }
}
public static void method2() {
    synchronized(obj) {
        // 同步块        
    }
}
```

### 加锁流程

1. 创建锁记录（Lock Record）对象，每个线程的帧栈都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word。

2. 让锁记录中的Object reference指向锁对象，并尝试用cas替换Object的Mark Word， 将Mark Word的值存入锁记录。

3. 如果cas替换（使内容交换位原子性的一个操作）成功，对象头中存储了**锁记录地址和状态（00）**，表示由该线程给对象加锁。

    其实是Mark Word中原有的内容和Lock Record中的内容对调，即原本的hashcode age等存放在Lock Record然后Lock Record的锁记录地址什么的进入Mark Word中

4. 如果cas失败，有两种情况：
    1. 如果是其他线程已经持有了该Object的轻量级锁，这是说明有竞争，进入锁膨胀过程
    2. 如果是自己执行了synchronized锁重入，那么在添加一条Lock Record作为重入的计数（内容为null，没进行cas）
    
### 解锁流程

1. 当退出synchronized代码块（解锁）时，如果有取值为null的记录，表示有重入，这时重置锁记录，表示重入计数减一

2. 当退出synchronized代码块（解锁）时，如果取值不为null，这是将使用cas将Mark Word的内容恢复给对象
    1. 成功则解锁成功
    2. 失败则说明轻量级锁已经进行锁膨胀或升级为重量级锁，进入重量级锁解锁流程
    
## （二）锁膨胀

如果在尝试加轻量级锁的过程中，cas操作无法成功，一种情况就是有其他线程为此对象将上了轻量级锁（竞争），这时需要锁膨胀，将其轻量级锁变成重量级锁。

```java
static Object obj = new Object();
public static void method1() {
    synchronized(obj) {
        // 同步块    
    }    
}
```

### 加、解锁流程

1. 当Thread-1进行轻量级加锁时，Thread-0已经对该对象进行了加轻量级锁。
2. 这时Thread-1加轻量级锁失败，进入锁膨胀过程：
    1. 即让Object对象申请Monitor锁，让Object指向重量级锁地址。
    2. 然后自己进入Monitor的EntryList BLOCKED（自己进去休息）
    
3. 当Thread-0退出同步代码块时，使用cas将Mark Word恢复给对象，这时失败！因为对象内已经是指向重量级锁了，所以进入重量级锁解锁流程：
    1. 按照Monitor地址找到Monitor对象
    2. 将Owner设置为null（原本指向的是Thread-0，即初始拥有者）
    3. 唤醒EntryList中BLOCKED线程
    
## （三）自旋优化

重量级锁竞争的时候，还可以使用自旋来优化，如果当前线程自旋成功（即这个时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。

### 自旋重试成功的情况

```java
// TODO: P81
```

### 自旋重试失败的情况

## （四）偏向锁

轻量锁在没有竞争时（就自己这个线程），每次重入仍需要CAS操作。

> Java6中引入了偏向锁来做进一步优化：只有第一次使用cas将线程id设置到对象的Mark Word头，之后发现这个线程ID是自己的，就表示没有竞争，不用重新cas。以后只要不发生竞争，这个对象就归该线程所有。

其实就是重入的时候没有多进行一次cas，也就是Lock Record中的内容是null。

### 补充64位的Mark Word

```text
|----------------------------------------------------------------------|--------------------|
|                          Mark Word(64 bits)                          |       State        |
|----------------------------------------------------------------------|--------------------|
| unused: 25 | hashcode: 31 | unused: 1 | age: 4 | biased_lock: 0 | 01 |       Normal       |
|----------------------------------------------------------------------|--------------------|
| thread: 54 | epoch: 2     | unused: 1 | age: 4 | biased_lock: 1 | 01 |       Biased       |
|----------------------------------------------------------------------|--------------------|
|                      ptr_to_lock_record: 62                     | 00 | Lightweight Locked |
|----------------------------------------------------------------------|--------------------|
|                  ptr_to_heavyweight_monitor: 62                 | 10 | Heavyweight_Locked |
|----------------------------------------------------------------------|--------------------|
|                                                                 | 11 |    Marked for GC   |
|----------------------------------------------------------------------|--------------------|
```

### 偏向状态

一个对象创建时:
* 如果开开启了偏向锁（默认开启），那么创建对象后，Mark Word的值为0x05即最后三位101（biased_lock:1 | 01），这是他的thread、epoc、age都是0
* 偏向锁默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加VM参数`-XX:BiasedLockingStartupDelay=0`来禁用延迟。
* 如果没有开启偏向锁，那么对象创建后Mark Word的值为0x01，即001，这时他的hashcode、age都是0，第一次用到hashcode时才会赋值。

[参考代码](../../20-TestBiased)

使用ClassLayout来获取VM中的value，添加VM Options后可以发现两次打印都是0x05！